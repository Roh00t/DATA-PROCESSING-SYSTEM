// Preprocessors Directives:
#include <iostream>
#include <vector>
#include <cmath>
#include <string>
#include <algorithm>

// Header Files:
#include "Point2D.h"
#include "Point3D.h"
#include "Line2D.h"
#include "Line3D.h"
#include "algorithms.h"
#include "GraphicRepresentation.h"


// Declaration of variables:


//This is a function declaration for a DDA function that takes two Point2D objects (p1 and p2) and returns a vector of Point2D objects:
// Purpose: The DDA function (Digital Differential Analyzer) is typically used to generate a list of points that form a line between two given points:
vector<Point2D> DDA(Point2D p1, Point2D p2); 

//Purpose: These constants set the size of the grid that will be used for plotting:
const int height = 25;
const int width = 50;

// These are scaling factors for 2D and 3D points, respectively:
// Purpose: The scaling factors adjust the size of the points/lines to ensure they fit within the grid:
int scale2d = 1;
int scale = 1;

//This initializes center_Point to the center of the grid:
// Purpose: The center point is often used as a reference for drawing axes or symbolmetrical objects:
Point2D center_Point = Point2D(height / 2, width / 2);

// This initializes left_Point to be at the center left edge of the grid (middle row, first column):
// Purpose: This might be used to define the start of the X-axis or a reference point on the grid:
Point2D left_Point = Point2D(height / 2, 0);

// This initializes right_Point to be at the center right edge of the grid (middle row, last column):
// Purpose: This could be used to define the end of the X-axis or another reference point:
Point2D right_Point = Point2D(height / 2, width - 1);

// This initializes top_Point to the top center of the grid (first row, middle column):
// Purpose: This might define the top of the Y-axis or a reference point at the top of the grid:
Point2D top_Point = Point2D(0, width / 2);

// This initializes bottom_Point to the bottom center of the grid (last row, middle column):
// Purpose: This could define the bottom of the Y-axis or another reference point:
Point2D bottom_Point = Point2D(height - 1, width / 2);

// This initializes diag_top to a point slightly to the left of the top center:
// Purpose: This might be used to define the start of a diagonal line on the grid:
Point2D diag_top = Point2D(0, width / 2 - 12);

// This initializes diag_bottom to a point slightly to the right of the bottom center:
// Purpose: This could define the end of a diagonal line on the grid:
Point2D diag_bottom = Point2D(height - 1, width / 2 + 12);

// Function prototypes:

// This function prototype suggests that check_line checks if a point (x, y) lies on a line defined by a vector of Point2D points:
// Purpose: It could be used to verify if a particular point is on a line generated by the DDA function or another line-drawing algorithm:
bool check_line(int x, int y, vector<Point2D> l);

// This function likely checks if a 3D point (x, y, z) is within certain bounds after scaling:
// Purpose: This function ensures that the 3D point, when scaled, still fits within the grid:
bool scale_check(int x, int y, int z);


// This function likely checks if a 2D point (x, y) is within the grid bounds:
// Purpose: It ensures that a 2D point is valid for plotting on the grid:
bool check_2d(int x, int y);


// This function likely checks if a line between two 2D points (x1, y1) and (x2, y2) is within bounds after scaling:
// Purpose: It ensures that the entire line segment is valid and fits within the grid after scaling:
bool scale_check_line2d(int x1, int y1, int x2, int y2);

// Draw point2d:
// Visualizes a 2D point in a simple coordinate system:

/*

Legend:

		Grid Representation:
		"O": Origin (0,0)
		"X": Positive X-axis
		"Y": Positive Y-axis
		"*": The point you want to draw

Expected Output:

		Y
		|   *
		|  
		O---------
			X


*/

void GenerateP2D(Point2D p)
{

	cout << "Projection of Point2D[" << p.getX() << ", " << p.getY() << "]" << endl;

	
	int my_x = p.getX();
	int my_y = p.getY();


	// Find suitable scale
	while (!check_2d(my_x, my_y))
	{

		scale2d++;

	} // end of while statement

	my_x = my_x / scale2d;
	my_y = my_y / scale2d;


	int x = 0;
	int y = 0;


	int xmax;
	int ymax;
	int xmin;
	int ymin;


	if (p.getX() < 0)
	{

		xmin = my_x - 2;
		xmax = 2;

	}
	else
	{

		xmin = 0;
		xmax = my_x + 2;

	}// end of if else statement

	if (p.getY() < 0)
	{

		ymin = my_y - 2;
		ymax = 2;

	}
	else
	{

		ymin = 0;
		ymax = my_y + 2;

	} // end of if else statement

	// Draw
	cout << "Current scale (one '_'): " << scale2d << endl;
	
	for (y = ymax; y >= ymin; y--)
	{

		string symbol = "";
		cout << endl;


		for (x = xmin; x <= xmax; x++)
		{

			if (x == 0 && y == 0)
			{

				symbol = "0";

			}
			else if (x == 0)
			{

				if (y == ymax)
				{

					symbol = "Y";

				}
				else
				{

					symbol = "|";

				}

			}
			else
			{

				if (y == 0)
				{

					if (x >= xmin || x <= xmax)
					{

						if (x == xmax)
						{

							symbol = " X";

						}
						else
						{

							symbol = "-";

						}// end of  inner  if else statement

					}// end of if statement

				}
				else
				{

					symbol = " ";

				}// end of  inner  if else statement

			}// end of if else statement


			if (x == my_x && y == my_y)
			{

				symbol = "*";

			} // end of if statement

			cout << symbol;

		} // end of for loop for (x = xmin; x <= xmax; x++)

	} // end of for loop for (y = ymax; y >= ymin; y--)


	scale2d = 1;
	cout << endl;
	cout << endl;

} // end of void GenerateP2D(Point2D p)

// Draw point3D:
//  Projects a 3D point onto a 2D plane and visualizes it in a text-based coordinate system:

/*

Legend:

		Axes Representation:
		"O": Origin (0,0,0)
		"X", "Y", "Z": The positive directions of the respective axes.
		"*": The projected point.

Expected Output:

		Z
		|
		|     *
		|   
		O--------X
		\
		 \
			Y

*/


void GenerateP3D(Point3D p)
{

	vector<Point2D> x_axis_left = DDA(left_Point, center_Point);
	vector<Point2D> x_axis_right = DDA(center_Point, right_Point);
	vector<Point2D> z_axis_top = DDA(center_Point, top_Point);
	vector<Point2D> z_axis_bottom = DDA(center_Point, bottom_Point);
	vector<Point2D> y_axis_top = DDA(center_Point, diag_top);
	vector<Point2D> y_axis_bottom = DDA(center_Point, diag_bottom);

	// Convert to point 2D
	Point2D p1 = Normalize(p);
	cout << "Projection of Point3D[" << p.getX() << ", " << p.getY() << ", " << p.getZ() << "]" << endl;
	cout << "Current scale: " << scale << endl;

	// Draw
	for (int i = 0; i < height; i++)
	{

		for (int j = 0; j < width; j++)
		{

			string symbol = "";


			if (i == top_Point.getX() && j == top_Point.getY())
			{

				symbol = "Z";

			}
			else if (i == right_Point.getX() && j == right_Point.getY())
			{

				symbol = "X";

			}
			else if (i == diag_bottom.getX() && j == diag_bottom.getY())
			{

				symbol = "Y";

			}
			else
			{

				if (check_line(i, j, x_axis_left) || check_line(i, j, x_axis_right))
				{

					symbol = "-";

				}
				else if (check_line(i, j, z_axis_top) || check_line(i, j, z_axis_bottom))
				{

					symbol = "|";

				}
				else if (check_line(i, j, y_axis_top) || check_line(i, j, y_axis_bottom))
				{

					symbol = "\\";

				}
				else
				{

					symbol = " ";

				} // end of inner if else statement

			} // end of if else statement

			if (i == center_Point.getX() && j == center_Point.getY())
			{

				symbol = "O";

			} // end of if statement

			if (i == p1.getX() && j == p1.getY())
			{

				symbol = "*";

			} // end of if statement

			cout << symbol;

		} // end of for loop for (int j = 0; j < width; j++)

		cout << endl;

	} // end of for loop for (int i = 0; i < height; i++)

	scale = 1;
	cout << endl;
	cout << endl;

} // end of void GenerateP3D(Point3D p)

// Draw line 2D:
//Visualizes a 2D line in a simple coordinate system:

/*

Legend:

		Grid Representation:
		"A" and "B": The endpoints of the line.
		".": Points along the line.

Expected Output:

		Y
		|  
		|    A . . B
		| 
		O---------
			X


*/

void GenerateL2D(Line2D l)
{

	int x1 = l.getPt1().getX();
	int y1 = l.getPt1().getY();
	int x2 = l.getPt2().getX();
	int y2 = l.getPt2().getY();

	cout << "Projection of Line2D[ A(" << x1 << ", " << y1 << "), B(" << x2 << ", " << y2 << ") ]" << endl;

	while (!scale_check_line2d(x1, y1, x2, y2))
	{

		scale2d++;

	}

	int x = 0;
	int y = 0;

	int xmax;
	int xmin;
	int ymax;
	int ymin;

	x1 = x1 / scale2d;
	y1 = y1 / scale2d;
	x2 = x2 / scale2d;
	y2 = y2 / scale2d;

	vector<Point2D> line = DDA(Point2D(x1, y1), Point2D(x2, y2));

	xmax = max(x1, x2);
	xmin = min(x1, x2);
	ymax = max(y1, y2);
	ymin = min(y1, y2);

	if (xmax > 0)
	{

		if (xmin > 0)
		{

			xmax += 2;
			xmin = -1;

		}
		else
		{

			xmax += 2;
			xmin -= 2;

		} // end of inner if else statement

	}
	else
	{

		xmax = 1;
		xmin -= 2;

	} // end of if else statement

	if (ymax > 0)
	{

		if (ymin > 0)
		{

			ymax += 2;
			ymin = -1;

		}
		else
		{

			ymax += 2;
			ymin -= 2;

		} // end of inner if else statement

	}
	else
	{

		ymax = 1;
		ymin -= 2;

	} // end of if else statement

	cout << "Current scale (one '_'): " << scale2d << endl;


	for (y = ymax; y >= ymin; y--)
	{

		string symbol = "";
		cout << endl;

		for (x = xmin; x <= xmax; x++)
		{

			if (x == 0 && y == 0)
			{

				symbol = "0";

			}
			else if (x == 0)
			{

				if (y == ymax)
				{

					symbol = "Y";

				}
				else
				{

					symbol = "|";

				} // end of inner if else statement

			}
			else
			{
				if (y == 0)
				{

					if (x >= xmin || x <= xmax)
					{

						if (x == xmax)
						{

							symbol = " X";

						}
						else
						{

							symbol = "-";

						} // end of inner if else statement

					} // end of if statement

				}
				else
				{

					symbol = " ";

				} // end of inner if else statement

			} // end of if else statement


			if ((check_line(x, y, line)) && (symbol != "0"))
			{

				symbol = ".";

			} // end of if statement

			if (x == x1 && y == y1)
			{

				symbol = "A";

			} // end of if statement
			if (x == x2 && y == y2)
			{

				symbol = "B";

			} // end of if statement

			cout << symbol;

		} // end of for loop (x = xmin; x <= xmax; x++)

	} // end of for loop (y = ymax; y >= ymin; y--)

	scale2d = 1;
	cout << endl;
	cout << endl;


} // end of void GenerateL2D(Line2D l)

// Draw line 3D:
// Projects a 3D line onto a 2D plane and visualizes it in a text-based coordinate system:

/*

Legend:

Key Points:

		Axes Representation:
		"O": Origin (0,0,0)
		"X", "Y", "Z": The positive directions of the respective axes.
		"*": The projected point.


Expected Output:

		Z
		|
		|   A . . . . B
		|  
		O--------X
		\
		 \
			Y



*/


void GenerateL3D(Line3D l)
{

	int scale = 3;
	Point3D p1 = l.getPt1();
	Point3D p2 = l.getPt2();
	Point2D p3 = Normalize(p1);
	Point2D p4 = Normalize(p2);

	// Generate coordinate system
	vector<Point2D> x_axis_left = DDA(left_Point, center_Point);
	vector<Point2D> x_axis_right = DDA(center_Point, right_Point);
	vector<Point2D> z_axis_top = DDA(center_Point, top_Point);
	vector<Point2D> z_axis_bottom = DDA(center_Point, bottom_Point);
	vector<Point2D> y_axis_top = DDA(center_Point, diag_top);
	vector<Point2D> y_axis_bottom = DDA(center_Point, diag_bottom);
	vector<Point2D> line = DDA(p3, p4);

	// Draw
	cout << "Projection for Line3D [ A(" << p1.getX() << ", " << p1.getY() << ", " << p1.getZ() << "), B(" << p2.getX() << ", " << p2.getY() << ", " << p2.getZ() << ") ]" << endl;
	cout << "Current scale (one '-') = " << scale << endl;

	for (int i = 0; i < height; i++)
	{

		for (int j = 0; j < width; j++)
		{

			string symbol = "";


			if (i == top_Point.getX() && j == top_Point.getY())
			{

				symbol = "Z";

			}
			else if (i == right_Point.getX() && j == right_Point.getY())
			{

				symbol = "X";

			}
			else if (i == diag_bottom.getX() && j == diag_bottom.getY())
			{

				symbol = "Y";

			}
			else
			{

				if (check_line(i, j, x_axis_left) || check_line(i, j, x_axis_right))
				{

					symbol = "-";

				}
				else if (check_line(i, j, z_axis_top) || check_line(i, j, z_axis_bottom))
				{

					symbol = "|";

				}
				else if (check_line(i, j, y_axis_top) || check_line(i, j, y_axis_bottom))
				{

					symbol = "\\";

				}
				else
				{

					symbol = " ";

				} // end of inner if else statement

			} // end of if else statement

			if (i == center_Point.getX() && j == center_Point.getY())
			{

				symbol = "O";

			} // end of if statement

			if (check_line(i, j, line))
			{

				symbol = ".";

			} // end of if statement

			if (i == p3.getX() && j == p3.getY())
			{

				symbol = "A";

			} // end of if statement

			if (i == p4.getX() && j == p4.getY())
			{

				symbol = "B";

			} // end of if statement
			cout << symbol;

		} // end of for (int j = 0; j < width; j++)

		cout << endl;

	} // end of for (int i = 0; i < height; i++)



	scale = 1;
	cout << endl;
	cout << endl;

} // end of void GenerateL3D(Line3D l)


// Convert 3D to 2D:
// Converts a 3D point to a 2D point by projecting it onto a 2D plane:
Point2D Normalize(Point3D p)
{

	int x = p.getX();
	int y = p.getY();
	int z = p.getZ();


	while (!scale_check(x, y, z))
	{

		scale += 1;

	} // end of while loop
	x = x / scale;
	y = y / scale;
	z = z / scale;

	int current_x = center_Point.getX();
	int current_y = center_Point.getY();

	current_y += x;
	current_x += y;
	current_y += y;
	current_x -= z;
	return Point2D(current_x, current_y);

} // end of Point2D Normalize(Point3D p)

// Scale:
// Ensure that the points or lines fit within the boundaries of the drawing area:
bool scale_check(int x, int y, int z)
{
	if (abs(x / scale) >= 10)
	{

		return false;

	} // end of if statement

	if (abs(y / scale) >= 10)
	{

		return false;

	} // end of if statement

	if (abs(z / scale) >= 10)
	{

		return false;

	} // end of if statement

	if (center_Point.getX() + (y / scale) - (z / scale) <= 0)
	{

		return false;

	} // end of if statement

	if (center_Point.getX() + (y / scale) - (z / scale) >= 20)
	{

		return false;

	} // end of if statement

	return true;

} // end of bool scale_check(int x, int y, int z)

// Check the scaled coordinates of points or lines and adjust the scale if necessary:
bool scale_check_line2d(int x1, int y1, int x2, int y2)
{

	if (abs(x1 / scale2d) >= 20)
	{

		return false;

	} // end of if statement

	if (abs(y1 / scale2d) >= 20)
	{

		return false;

	} // end of if statement

	if (abs(x2 / scale2d) >= 20)
	{

		return false;

	} // end of if statement

	if (abs(y2 / scale2d) >= 20)
	{

		return false;

	} // end of if statement

	return true;

} // end of bool scale_check_line2d(int x1, int y1, int x2, int y2)

//  Determines if a specific point lies on a given line:
bool check_line(int x, int y, vector<Point2D> l)
{

	for (int i = 0; i < l.size(); i++)
	{

		if (x == l[i].getX() && y == l[i].getY())
		{

			return true;

		} // end of if statement

	}// end of for loop
	
	return false;

} // end of bool check_line(int x, int y, vector<Point2D> l)

// Ensures that a 2D point fits within the drawing area.
bool check_2d(int x, int y)
{
	if (abs(x / scale2d) >= 20)
	{

		return false;

	} // end of if statement

	if (abs(y / scale2d) >= 20)
	{

		return false;

	} // end of if statement

	return true;

} // end of bool check_2d(int x, int y)

// Implements the Digital Differential Analyzer (DDA) algorithm to compute the points of a line between two 2D points:
vector<Point2D> DDA(Point2D p1, Point2D p2)
{

	vector<Point2D> result;
	float x1 = p1.getX();
	float y1 = p1.getY();
	float x2 = p2.getX();
	float y2 = p2.getY();
	int k;

	float dx = x2 - x1;
	float dy = y2 - y1;

	if (abs(dx) >= abs(dy))
		k = abs(dx);
	else
		k = abs(dy);


	if (k != 0)
	{

		float xinc = dx / k;
		float yinc = dy / k;

		float x = x1;
		float y = y1;
		Point2D p;
		p.setX(x);
		p.setY(y);
		result.push_back(p);

		for (int i = 1; i < k; i++)
		{

			x = x + xinc;
			y = y + yinc;
			Point2D p;
			p.setX(x);
			p.setY(y);
			result.push_back(p);

		} // end of for loop

	}// end of if statement

	return result;
} // end of vector<Point2D> DDA(Point2D p1, Point2D p2)